<html>

<head>
    <title>Mazes</title>
    <style>
        .cell {
            background-color: #000;
            border: 1px solid transparent;
            float: left;
        }
        
        .visited {
            background-color: #dfa;
        }
        
        .breakRow {
            clear: both;
        }
        
        .loopedTo {
            background-color: #adf;
        }
        
        .loopedFrom {
            background-color: #fad;
        }
        /*.wallNorth { border-top: 1px solid #000; }*/
        /*.wallEast { border-right: 1px solid #000; }*/
        /*.wallSouth { border-bottom: 1px solid #000; }*/
        /*.wallWest { border-left: 1px solid #000; }*/
        
        .cell {
            height: 3px;
        }
        
        .cell {
            width: 3px;
        }
    </style>
</head>

<body>
    <div id="mazeWrapper"></div>
    <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
    <script>
        //+ Jonas Raoni Soares Silva
        //@ http://jsfromhell.com/array/shuffle [v1.0]
        if (!Array.prototype.shuffle) {
            Array.prototype.shuffle = function() { //v1.0
                var o = Object(this);
                for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
                return o;
            };
        };
        var MyMath = (function() {
            var ths = {};

            ths.randomOddInteger = function(lowerBound, upperBound, upperOffset) {
                var n = Math.floor(Math.random() * upperBound * 10) % upperBound;
                n = n <= lowerBound ? lowerBound : n;
                n = n % 2 == 0 ? n + 1 : n;
                n = n > upperBound - upperOffset - 1 ? upperBound - upperOffset - 1 : n;

                return n;
            };

            return ths;
        }());

        function Direction(x, y) {
            this.x = x;
            this.y = y;
        };
        Direction.prototype.opposite = function() {
            return new Direction(x * -1, y * -1);
        };

        function Cell(x, y) {
            this.x = x;
            this.y = y;
            this.regionConnections = [];
            this.visited = false;
            this.loopedTo = false;
            this.loopedFrom = false;
            this.region = -1;
            this.isConnection = false;
        };

        function Room(x, y, w, h) {
            this.position = {
                x: x,
                y: y
            };
            this.size = {
                width: w,
                height: h
            };

            this.top = this.position.y;
            this.bottom = this.position.y + this.size.height;
            this.left = this.position.x;
            this.right = this.position.x + this.size.width
        };
        Room.prototype.overlaps = function(room) {
            return !(this.left > room.right || this.right < room.left || this.top > room.bottom || this.bottom < room.top)
        };

        function Maze(columns, rows) {
            this.cells = new Array();
            this.rooms = new Array();
            this.columns = columns % 2 == 0 ? columns + 1 : columns;
            this.rows = rows % 2 == 0 ? rows + 1 : rows;
            this.directions = [
                new Direction(1, 0),
                new Direction(-1, 0),
                new Direction(0, 1),
                new Direction(0, -1)
            ];
            this.regions = [];
            this.currentRegion = 0;
            this.connections = [];
            this.multipleConnectionsForSameRegionChance = 0;
            this.roomMinSize = 5;
            this.roomMaxSize = 15;
            this.loopFactor = 7;
            this.steps = 0;
            this.backtrack = 0;
            this.maxBacktrack = 20;
            this.maxStepsBeforeBacktrack = 50;
            this.windingPercent = 50;
            this.maxRoomPlacementTries = 200;

            this.init();
        };
        Maze.prototype.init = function() {
            for (var c = 0; c < this.columns; c++) {
                this.cells[c] = [];
                for (var r = 0; r < this.rows; r++) {
                    this.cells[c][r] = new Cell(c, r);
                }
            }
        };
        Maze.prototype.containsPosition = function(x, y) {
            return x >= 0 && y >= 0 && x < this.columns && y < this.rows;
        };
        Maze.prototype.getCell = function(x, y) {
            if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
                return undefined;
            }
            return this.cells[x][y];
        };
        Maze.prototype.canCarve = function(cell, direction) {
            if (!this.containsPosition(cell.x + direction.x * 3, cell.y + direction.y * 3)) {
                return false;
            }
            return this.getCell(cell.x + direction.x * 2, cell.y + direction.y * 2).visited === false;
        };

        function MazeCarver(mz) {
            if (mz == null) {
                throw "cannot carve on null";
            }
            if (!(mz instanceof Maze)) {
                throw "must carve on a Maze";
            }

            this.maze = mz;
        }
        MazeCarver.prototype.generate = function() {
            this.addRooms();
            for (var y = 1; y < this.maze.rows; y += 2) {
                for (var x = 1; x < this.maze.columns; x += 2) {
                    var currentCell = this.maze.getCell(x, y);
                    if (currentCell.visited) {
                        continue;
                    }
                    this.growMaze(currentCell);
                }
            }
            this.addConnections();
            this.carveConnections();
            this.removeDeadEnds();
        };
        MazeCarver.prototype.addRooms = function() {
            for (var i = 0; i < this.maze.maxRoomPlacementTries; i++) {
                var roomWidth = MyMath.randomOddInteger(this.maze.roomMinSize, this.maze.roomMaxSize);
                var roomLength = MyMath.randomOddInteger(this.maze.roomMinSize, this.maze.roomMaxSize);
                var x = MyMath.randomOddInteger(0, this.maze.columns, roomWidth);
                var y = MyMath.randomOddInteger(0, this.maze.rows, roomLength);
                var currentRoom = new Room(x, y, roomWidth, roomLength);
                var overlaps = false;
                for (var r of this.maze.rooms) {
                    if (r.overlaps(currentRoom)) {
                        overlaps = true;
                        break;
                    }
                }
                if (overlaps) {
                    continue;
                }
                this.maze.rooms.push(currentRoom);
                this.carveRoom(currentRoom)
            }
        };
        MazeCarver.prototype.growMaze = function(startCell) {
            var possibleCells = [];
            var lastDirection;
            this.startRegion();
            this.carve(startCell);
            possibleCells.push(startCell);
            while (possibleCells.length > 0) {
                var cell = possibleCells[possibleCells.length - 1];
                var possibleDirections = [];
                for (var d of this.maze.directions.shuffle()) {
                    if (this.maze.canCarve(cell, d)) {
                        possibleDirections.push(d);
                    }
                }
                if (possibleDirections.length > 0) {
                    var carvingDirection;
                    if (possibleDirections.indexOf(lastDirection) >= 0 && Math.random() * 100 > this.maze.windingPercent) {
                        carvingDirection = lastDirection;
                    } else {
                        carvingDirection = possibleDirections.pop();
                    }
                    var toCarve = this.maze.getCell(cell.x + carvingDirection.x, cell.y + carvingDirection.y);
                    this.carve(toCarve);
                    toCarve = this.maze.getCell(cell.x + carvingDirection.x * 2, cell.y + carvingDirection.y * 2);
                    this.carve(toCarve);
                    possibleCells.push(toCarve);
                    lastDirection = carvingDirection;
                } else {
                    possibleCells.splice(possibleCells.length - 1, 1);
                    lastDirection = null;
                }
            }
        };
        MazeCarver.prototype.addConnections = function() {
            for (var y = 1; y < this.maze.rows - 1; y++) {
                for (var x = 1; x < this.maze.columns - 1; x++) {
                    var c = this.maze.getCell(x, y);
                    if (c.visited) {
                        continue;
                    }
                    var differingRegions = [];
                    var regionConnections = [];
                    for (var d of this.maze.directions) {
                        var neighbor = this.maze.getCell(c.x + d.x, c.y + d.y);
                        if (neighbor.visited && differingRegions.indexOf(neighbor.region) < 0) {
                            differingRegions.push(neighbor.region);
                            regionConnections.push(neighbor);
                        }
                    }
                    if (differingRegions.length >= 2) {
                        c.isConnection = true;
                        c.regionConnections = regionConnections;
                        this.maze.connections.push(c);
                    }
                }
            }
        };
        MazeCarver.prototype.carveConnections = function() {
            var shuffledConnections = this.maze.connections.shuffle();
            for (var cell of shuffledConnections) {
                var connectedToRegions = [];
                for (var connectionCell of cell.regionConnections) {
                    if (connectedToRegions.indexOf(connectionCell.region) < 0) {
                        connectedToRegions.push(connectionCell.region);
                    }
                }
                if (connectedToRegions.length >= 2 || (Math.random() * 100) < this.maze.multipleConnectionsForSameRegionChance) {
                    this.maze.currentRegion = connectedToRegions[0];
                    this.carve(cell);
                    if (connectedToRegions.length >= 2) {
                        this.mergeRegions(connectedToRegions[0], connectedToRegions[1]);
                    }
                } else {
                    cell.isConnection = false;
                }
            }
        };
        MazeCarver.prototype.removeDeadEnds = function() {
            var done = false;
            while (!done) {
                done = true;
                for (var y = 0; y < this.maze.rows; y++) {
                    for (var x = 0; x < this.maze.columns; x++) {
                        var cell = this.maze.getCell(x, y);
                        if (!cell.visited) {
                            continue;
                        }
                        var exits = [];
                        for (var dir of this.maze.directions) {
                            var neighbor = this.maze.getCell(x + dir.x, y + dir.y);
                            if (neighbor && neighbor.visited) {
                                exits.push(neighbor);
                            }
                        }
                        if (exits.length != 1) {
                            continue;
                        }
                        done = false;
                        this.maze.getCell(x, y).visited = false;
                    }
                }
            }
        };
        MazeCarver.prototype.mergeRegions = function(region1, region2) {
            for (var y = 0; y < this.maze.rows; y++) {
                for (var x = 0; x < this.maze.columns; x++) {
                    var cell = this.maze.getCell(x, y);
                    if (cell.region === region2) {
                        cell.region = region1;
                    }
                }
            }
        };
        MazeCarver.prototype.carveRoom = function(room) {
            this.startRegion();
            for (var c = room.position.x; c < room.position.x + room.size.width; c++) {
                for (var r = room.position.y; r < room.position.y + room.size.height; r++) {
                    this.carve(this.maze.getCell(c, r));
                }
            }
        };
        MazeCarver.prototype.startRegion = function() {
            this.maze.currentRegion += 1;
        };
        MazeCarver.prototype.carve = function(cell) {
            cell.visited = true;
            cell.region = this.maze.currentRegion;
        };

        $(document).ready(function() {
            console.log("START:", (new Date()).toJSON());
            var m = new Maze(25, 25);
            var mc = new MazeCarver(m);
            mc.generate();
            console.log("MAZE:", (new Date()).toJSON());

            var handler = function() {
                console.log($(this).data());
                return true;
            };
            for (var r = 0; r < mc.maze.rows; r++) {
                for (var c = 0; c < mc.maze.columns; c++) {
                    var cellData = mc.maze.getCell(c, r);
                    var cellUi = $("<div/>")
                        .addClass("cell")
                        .data(cellData)
                        .on("click", handler);
                    //formatting
                    if (c === 0) {
                        cellUi.addClass("breakRow");
                    }
                    if (cellData.visited) {
                        cellUi.addClass("visited");
                    }
                    if (cellData.isConnection) {
                        cellUi.addClass("loopedTo");
                    }
                    $("#mazeWrapper").append(cellUi);
                }
            }
            console.log("END:", (new Date()).toJSON());
        });
    </script>
</body>

</html>
